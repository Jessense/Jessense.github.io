<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Jessense's Blog</title><link>https://jessense.github.io/</link><description>Recent content on Jessense's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://jessense.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Rclone + Google Drive + Aria2 + Emby 搭建个人影音系统</title><link>https://jessense.github.io/posts/rclone-aria2-emby-streaming/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jessense.github.io/posts/rclone-aria2-emby-streaming/</guid><description>What are we building? 无限容量
rclone 详细教程 https://rclone.org/install/
https://rclone.org/drive/
2.1 https://rclone.org/drive/#making-your-own-client-id
在Debian/Ubuntu上使用rclone挂载Google Drive网盘 - Rat&amp;rsquo;s Blog
解决Rclone挂载Google Drive时上传失败和内存占用高等问题 - Rat&amp;rsquo;s Blog
快速步骤 安装：
curl https://rclone.org/install.sh | sudo bash 配置：
rclone config 配置参考2和4，这里建议生成自己的的 Google Drive client_id（详见2.1）。
挂载：
mkdir ~/GoogleDrive rclone mount RemoteName:Folder ~/GoogleDrive --copy-links --no-gzip-encoding --no-check-certificate --allow-other --allow-non-empty --umask 000 其中 DriveName 是上一步配置中设置的remote的Name，Folder是Google Drive的一个子文件夹。
Aria2 P3TERX/aria2.sh: Aria2 一键安装管理脚本 增强版
wget -N git.</description></item><item><title>手写定时器</title><link>https://jessense.github.io/posts/timerqueue/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jessense.github.io/posts/timerqueue/</guid><description>#include&amp;lt;iostream&amp;gt;#include&amp;lt;vector&amp;gt;#include&amp;lt;map&amp;gt;#include&amp;lt;queue&amp;gt;#include&amp;lt;time.h&amp;gt;#include&amp;lt;pthread.h&amp;gt;#include&amp;lt;unistd.h&amp;gt;using namespace std; typedef void*(*callback_t) (void*); struct timer { timespec expire; callback_t callback; timer(timespec expire_, callback_t callback_) : expire(expire_), callback(callback_) { } }; // 主线程添加的 timer，子线程需要处理 vector&amp;lt;timer&amp;gt; pending_timers; pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; pthread_cond_t cond = PTHREAD_COND_INITIALIZER; timespec get_epoch_now() { timespec now; clock_gettime(CLOCK_REALTIME, &amp;amp;now); return now; } bool earlier(const timespec&amp;amp; a, const timespec&amp;amp; b) { return a.tv_sec &amp;lt; b.tv_sec || (a.tv_sec == b.tv_sec &amp;amp;&amp;amp; a.tv_nsec &amp;lt; b.tv_nsec); } void* eventloop(void* data) { auto cmp = [](timer a, timer b) { return earlier(b.</description></item></channel></rss>